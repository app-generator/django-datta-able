# coding: utf-8

"""
    DHL Express APIs (MyDHL API)

    Welcome to the official DHL Express APIs (MyDHL API) below are the published API Documentation to fulfill your shipping needs with DHL Express.       Please follow the process described [here](https://developer.dhl.com/api-reference/dhl-express-mydhl-api#get-started-section/user-guide--get-access) to request access to the DHL Express - MyDHL API services   In case you already have DHL Express - MyDHL API Service credentials please ensure to use the endpoints/environments listed  [here](https://developer.dhl.com/api-reference/dhl-express-mydhl-api#get-started-section/user-guide--environments) 

    The version of the OpenAPI document: 2.11.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.estimated_delivery_date1 import EstimatedDeliveryDate1
from openapi_client.models.monetary_amount_inner import MonetaryAmountInner
from openapi_client.models.supermodel_io_logistics_express_account import SupermodelIoLogisticsExpressAccount
from openapi_client.models.supermodel_io_logistics_express_package_rr import SupermodelIoLogisticsExpressPackageRR
from openapi_client.models.supermodel_io_logistics_express_rate_request_customer_details import SupermodelIoLogisticsExpressRateRequestCustomerDetails
from openapi_client.models.supermodel_io_logistics_express_rate_request_get_additional_information_inner import SupermodelIoLogisticsExpressRateRequestGetAdditionalInformationInner
from openapi_client.models.supermodel_io_logistics_express_rate_request_products_and_services_inner import SupermodelIoLogisticsExpressRateRequestProductsAndServicesInner
from openapi_client.models.supermodel_io_logistics_express_value_added_services_rates import SupermodelIoLogisticsExpressValueAddedServicesRates
from typing import Optional, Set
from typing_extensions import Self

class SupermodelIoLogisticsExpressRateRequest(BaseModel):
    """
    Definition of /rates request message
    """ # noqa: E501
    customer_details: SupermodelIoLogisticsExpressRateRequestCustomerDetails = Field(alias="customerDetails")
    accounts: Optional[Annotated[List[SupermodelIoLogisticsExpressAccount], Field(max_length=2)]] = Field(default=None, description="Please enter all the DHL Express accounts and types to be used for this shipment")
    product_code: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=6)]] = Field(default=None, description="Please enter DHL Express Global Product code", alias="productCode")
    local_product_code: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=3)]] = Field(default=None, description="Please enter DHL Express Local Product code", alias="localProductCode")
    value_added_services: Optional[Annotated[List[SupermodelIoLogisticsExpressValueAddedServicesRates], Field(max_length=99)]] = Field(default=None, description="Please use if you wish to filter the response by value added services", alias="valueAddedServices")
    products_and_services: Optional[List[SupermodelIoLogisticsExpressRateRequestProductsAndServicesInner]] = Field(default=None, description="Please use if you wish to filter the response by product(s) and/or value added services", alias="productsAndServices")
    payer_country_code: Optional[Annotated[str, Field(min_length=2, strict=True, max_length=2)]] = Field(default=None, description="payerCountryCode is to be provided if your profile has been enabled to view rates without an account number (this will provide DHL Express published rates for the payer country)", alias="payerCountryCode")
    planned_shipping_date_and_time: Annotated[str, Field(min_length=1, strict=True, max_length=29)] = Field(description="Identifies the date and time the package is tendered. Both the date and time portions of the string are expected to be used. The date should not be a past date or a date more than 10 days in the future. The time is the local time of the shipment based on the shipper's time zone. The date component must be in the format: YYYY-MM-DD; the time component must be in the format: HH:MM:SS using a 24 hour clock. The date and time parts are separated by the letter T (e.g. 2006-06-26T17:00:00 GMT+01:00).", alias="plannedShippingDateAndTime")
    unit_of_measurement: StrictStr = Field(description="Please enter Unit of measurement - metric,imperial", alias="unitOfMeasurement")
    is_customs_declarable: StrictBool = Field(description="For customs purposes please advise if your shipment is dutiable (true) or non dutiable (false)", alias="isCustomsDeclarable")
    monetary_amount: Optional[List[MonetaryAmountInner]] = Field(default=None, description="Please provide monetary amount related to your shipment, for example shipment declared value", alias="monetaryAmount")
    request_all_value_added_services: Optional[StrictBool] = Field(default=None, description="Legacy field and replaced by newer field getAdditionalInformation. Please set this to true to receive all value added services for each product available", alias="requestAllValueAddedServices")
    estimated_delivery_date: Optional[EstimatedDeliveryDate1] = Field(default=None, alias="estimatedDeliveryDate")
    get_additional_information: Optional[Annotated[List[SupermodelIoLogisticsExpressRateRequestGetAdditionalInformationInner], Field(max_length=3)]] = Field(default=None, description="Provides additional information in the response like all value added services, and rule groups", alias="getAdditionalInformation")
    return_standard_products_only: Optional[StrictBool] = Field(default=None, description="Please set this to true to filter out all products which needs DHL Express special customer agreement", alias="returnStandardProductsOnly")
    next_business_day: Optional[StrictBool] = Field(default=False, description="Please set this to true in case you want to receive products which are not available on planned shipping date but next available day", alias="nextBusinessDay")
    product_type_code: Optional[StrictStr] = Field(default=None, description="Please select which type of priducts you are interested in", alias="productTypeCode")
    packages: Annotated[List[SupermodelIoLogisticsExpressPackageRR], Field(min_length=1, max_length=999)] = Field(description="Here you can define properties per package")
    __properties: ClassVar[List[str]] = ["customerDetails", "accounts", "productCode", "localProductCode", "valueAddedServices", "productsAndServices", "payerCountryCode", "plannedShippingDateAndTime", "unitOfMeasurement", "isCustomsDeclarable", "monetaryAmount", "requestAllValueAddedServices", "estimatedDeliveryDate", "getAdditionalInformation", "returnStandardProductsOnly", "nextBusinessDay", "productTypeCode", "packages"]

    @field_validator('unit_of_measurement')
    def unit_of_measurement_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['metric', 'imperial']):
            raise ValueError("must be one of enum values ('metric', 'imperial')")
        return value

    @field_validator('product_type_code')
    def product_type_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['all', 'dayDefinite', 'timeDefinite']):
            raise ValueError("must be one of enum values ('all', 'dayDefinite', 'timeDefinite')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SupermodelIoLogisticsExpressRateRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of customer_details
        if self.customer_details:
            _dict['customerDetails'] = self.customer_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in accounts (list)
        _items = []
        if self.accounts:
            for _item in self.accounts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['accounts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in value_added_services (list)
        _items = []
        if self.value_added_services:
            for _item in self.value_added_services:
                if _item:
                    _items.append(_item.to_dict())
            _dict['valueAddedServices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in products_and_services (list)
        _items = []
        if self.products_and_services:
            for _item in self.products_and_services:
                if _item:
                    _items.append(_item.to_dict())
            _dict['productsAndServices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in monetary_amount (list)
        _items = []
        if self.monetary_amount:
            for _item in self.monetary_amount:
                if _item:
                    _items.append(_item.to_dict())
            _dict['monetaryAmount'] = _items
        # override the default output from pydantic by calling `to_dict()` of estimated_delivery_date
        if self.estimated_delivery_date:
            _dict['estimatedDeliveryDate'] = self.estimated_delivery_date.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in get_additional_information (list)
        _items = []
        if self.get_additional_information:
            for _item in self.get_additional_information:
                if _item:
                    _items.append(_item.to_dict())
            _dict['getAdditionalInformation'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in packages (list)
        _items = []
        if self.packages:
            for _item in self.packages:
                if _item:
                    _items.append(_item.to_dict())
            _dict['packages'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SupermodelIoLogisticsExpressRateRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "customerDetails": SupermodelIoLogisticsExpressRateRequestCustomerDetails.from_dict(obj["customerDetails"]) if obj.get("customerDetails") is not None else None,
            "accounts": [SupermodelIoLogisticsExpressAccount.from_dict(_item) for _item in obj["accounts"]] if obj.get("accounts") is not None else None,
            "productCode": obj.get("productCode"),
            "localProductCode": obj.get("localProductCode"),
            "valueAddedServices": [SupermodelIoLogisticsExpressValueAddedServicesRates.from_dict(_item) for _item in obj["valueAddedServices"]] if obj.get("valueAddedServices") is not None else None,
            "productsAndServices": [SupermodelIoLogisticsExpressRateRequestProductsAndServicesInner.from_dict(_item) for _item in obj["productsAndServices"]] if obj.get("productsAndServices") is not None else None,
            "payerCountryCode": obj.get("payerCountryCode"),
            "plannedShippingDateAndTime": obj.get("plannedShippingDateAndTime"),
            "unitOfMeasurement": obj.get("unitOfMeasurement"),
            "isCustomsDeclarable": obj.get("isCustomsDeclarable"),
            "monetaryAmount": [MonetaryAmountInner.from_dict(_item) for _item in obj["monetaryAmount"]] if obj.get("monetaryAmount") is not None else None,
            "requestAllValueAddedServices": obj.get("requestAllValueAddedServices"),
            "estimatedDeliveryDate": EstimatedDeliveryDate1.from_dict(obj["estimatedDeliveryDate"]) if obj.get("estimatedDeliveryDate") is not None else None,
            "getAdditionalInformation": [SupermodelIoLogisticsExpressRateRequestGetAdditionalInformationInner.from_dict(_item) for _item in obj["getAdditionalInformation"]] if obj.get("getAdditionalInformation") is not None else None,
            "returnStandardProductsOnly": obj.get("returnStandardProductsOnly"),
            "nextBusinessDay": obj.get("nextBusinessDay") if obj.get("nextBusinessDay") is not None else False,
            "productTypeCode": obj.get("productTypeCode"),
            "packages": [SupermodelIoLogisticsExpressPackageRR.from_dict(_item) for _item in obj["packages"]] if obj.get("packages") is not None else None
        })
        return _obj



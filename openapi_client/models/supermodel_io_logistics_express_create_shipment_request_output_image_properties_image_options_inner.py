# coding: utf-8

"""
    DHL Express APIs (MyDHL API)

    Welcome to the official DHL Express APIs (MyDHL API) below are the published API Documentation to fulfill your shipping needs with DHL Express.       Please follow the process described [here](https://developer.dhl.com/api-reference/dhl-express-mydhl-api#get-started-section/user-guide--get-access) to request access to the DHL Express - MyDHL API services   In case you already have DHL Express - MyDHL API Service credentials please ensure to use the endpoints/environments listed  [here](https://developer.dhl.com/api-reference/dhl-express-mydhl-api#get-started-section/user-guide--environments) 

    The version of the OpenAPI document: 2.11.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class SupermodelIoLogisticsExpressCreateShipmentRequestOutputImagePropertiesImageOptionsInner(BaseModel):
    """
    SupermodelIoLogisticsExpressCreateShipmentRequestOutputImagePropertiesImageOptionsInner
    """ # noqa: E501
    type_code: StrictStr = Field(description="Please enter the document type you want to wish set properties for", alias="typeCode")
    template_name: Optional[Annotated[str, Field(strict=True, max_length=25)]] = Field(default=None, description="Please enter DHL Express document template name. <BR>                Sample Transport label templates:<BR>                ECOM26_84_A4_001 <BR>                ECOM26_84_001 - default<BR>                ECOM_TC_A4<BR>                ECOM26_A6_002<BR>                ECOM26_84CI_001<BR>                ECOM26_84CI_002 - supported single customer barcode<BR>                ECOM26_84CI_003 - to be used if customer barcodes are used<BR>                ECOM_A4_RU_002<BR> ECOM26_84_LBBX_001 - supported for loose BBX shipment<BR> ECOM26_64_LBBX_001 - supported for loose BBX shipment<BR>Sample WaybillDoc templates<BR>                ARCH_8X4_A4_002<BR>                ARCH_8X4 - default<BR>                ARCH_6X4<BR>                ARCH_A4_RU_002<BR>                <BR>                Sample Commercial invoice templates:<BR>                COMMERCIAL_INVOICE_04 - This template can print the Shipper, Recipient, and Buyer and Importer address details and is on portrait orientation, exclusive use for preparing Loose BBX shipment.<BR>                COMMERCIAL_INVOICE_P_10 - (default) This template can print the Shipper, Recipient and upto two more additional address details in portrait orientation. Note: If customer provided more than four address roles in the request message and this template is selected, the rendered invoice will only contain four address roles based on order of priority: Shipper, Recipient, Seller, Importer, Exporter, Buyer. <BR>                COMMERCIAL_INVOICE_L_10 - This template can print the Shipper,Recipient, Buyer, and Importer and Exporter address details and is on landscape orientation..<BR>                RET_COM_INVOICE_A4_01 - This template can print the Shipper, Recipient and Importer of record address details and is on landscape orientation. This template is for exclusive use for certain shipment where the goods are actual 'returns'. The Shipper is the party that earlier has received the goods, but now wishes to return the goods to its originating party. The Recipient in this shipment scenario will receive the 'returned goods'. Therefore such request of shipment with an invoice rendering may utilize the specific invoice template for 'Returns Invoice'.<BR>                <BR>                Sample Shipment Receipt template<BR>                SHIP_RECPT_A4_RU_002<BR> SHIPRCPT_EN_001 - default <BR> <BR> Sample QR Code template template<BR>  QR_1_00_LL_PNG_001 - default", alias="templateName")
    is_requested: Optional[StrictBool] = Field(default=None, description="To be used for waybillDoc, invoice, shipment receipt and QRcode. If set to true then the document is provided otherwise not", alias="isRequested")
    hide_account_number: Optional[StrictBool] = Field(default=None, description="To be used for waybillDoc. If set to true then account information will not be printed on the waybillDoc", alias="hideAccountNumber")
    number_of_copies: Optional[Union[Annotated[float, Field(le=2, strict=True, ge=1)], Annotated[int, Field(le=2, strict=True, ge=1)]]] = Field(default=None, description="You can ask up to 2 waybillDoc copies to be provided", alias="numberOfCopies")
    invoice_type: Optional[StrictStr] = Field(default=None, description="Please advise what type of customs documentation is required", alias="invoiceType")
    language_code: Optional[Annotated[str, Field(min_length=3, strict=True, max_length=3)]] = Field(default=None, description="Please enter ISO 3 letters language code for invoice or shipment receipt", alias="languageCode")
    language_country_code: Optional[Annotated[str, Field(min_length=2, strict=True, max_length=2)]] = Field(default=None, description="Please enter ISO 2 letters language country code for invoice or shipment receipt", alias="languageCountryCode")
    language_script_code: Optional[Annotated[str, Field(min_length=4, strict=True, max_length=4)]] = Field(default=None, description="Please enter ISO 4 letters language script code for shipment receipt", alias="languageScriptCode")
    encoding_format: Optional[StrictStr] = Field(default=None, description="Please provide the format of the QR Code output format.", alias="encodingFormat")
    render_dhl_logo: Optional[StrictBool] = Field(default=None, description="DHL Logo to be printed in Transport Label or Waybill Document", alias="renderDHLLogo")
    fit_labels_to_a4: Optional[StrictBool] = Field(default=None, description="To print respective Transport Label and Waybill document into A4 margin PDF.<BR>                Note: ECOM26_A6_002,ECOM26_84CI_001,ECOM26_84CI_002,ARCH_6X4,ARCH_8X4 template. <BR>                This option is applicable only for PDF encodingFormat selection.<BR>                false: Transport Label and Waybill document will use default margin settings (default behavior) <BR>                true: Transport Label and Waybill document will print into A4 margin PDF", alias="fitLabelsToA4")
    label_free_text: Optional[Annotated[str, Field(strict=True, max_length=150)]] = Field(default=None, description="Additional customer label free text that can be printed in certain label.Note: Applicable only to ECOM26_A6_002, ECOM_TC_A4 and ECOM26_84CI_001.", alias="labelFreeText")
    label_customer_data_text: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=250)]] = Field(default=None, description="Additional customer label text that can be printed in certain label.Note: Applicable only to ECOM26_84_A4_001, ECOM_TC_A4 and ECOM26_84CI_001", alias="labelCustomerDataText")
    shipment_receipt_customer_data_text: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=700)]] = Field(default=None, description="Declaration text that can be printed in certain shipment receipt template", alias="shipmentReceiptCustomerDataText")
    __properties: ClassVar[List[str]] = []

    @field_validator('type_code')
    def type_code_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['label', 'waybillDoc', 'invoice', 'qr-code', 'shipmentReceipt']):
            raise ValueError("must be one of enum values ('label', 'waybillDoc', 'invoice', 'qr-code', 'shipmentReceipt')")
        return value

    @field_validator('invoice_type')
    def invoice_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['commercial', 'proforma', 'returns']):
            raise ValueError("must be one of enum values ('commercial', 'proforma', 'returns')")
        return value

    @field_validator('encoding_format')
    def encoding_format_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['png']):
            raise ValueError("must be one of enum values ('png')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SupermodelIoLogisticsExpressCreateShipmentRequestOutputImagePropertiesImageOptionsInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SupermodelIoLogisticsExpressCreateShipmentRequestOutputImagePropertiesImageOptionsInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
        })
        return _obj


